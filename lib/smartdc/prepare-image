#!/usr/local/bin/bash
#
# Copyright (c) 2013 Joyent Inc., All rights reserved.
#
# Script that will prepare a FreeBSD image to have an insance made out of it

# This is script will prepare the root disk ( only the disk with the OS ) to be provisionable as a new image
# This requires deletion of files on the root disk and is not recomended for production systems to use this script
# The script also has many checks to ensure that a system is properly configured to be a provisionable Joyent image
# After the OS disk is prepared for imaging it is copied to an image disk ( that Joyent Support needs to create )
# The image disk allows for the smallest image size and quickest provisioning of new datasets
# Once this script is ran customers need to contact Joyent Support to create a dataset from the image disk

# load common functions and vars
. /lib/smartdc/lib_smartdc_scripts.cfg

# target distro that this script is engineered for 
# Please do not change this as it is a QA check to
# ensure that all is getting done to make good images
TARGET_DISTRO='freebsd'

# Disk that is copied from for images
SOURCE_DISK='vtbd0'

# Disk used for images of dataset to be copied to
IMAGE_DISK='vtbd2'

# initilize warning string
WARNING=""

addwarn() {
  # array for warnings
  WARNING="${WARNING}(warning) $@\n"
}

warn() {
  # print warnings function
  printf "(warn) %s\n" "$@"
}

separator() {
  # pretty seperator generator
  for i in {1..78} ; do
    printf "="
  done
  printf "\n"
}

check_for_smartdc() {
# Joyent installs a custom install of Node.JS and smartdc 
# This checks to ensure that this is installed

  lib_smartdc_info "checking for JPC install of the JPC Cloud API utilties Node.JS SmartDC"
  if [[ ! -d /opt/local/smartdc ]] ; then
     lib_smartdc_info "MISSING /opt/local/smartdc - JPC Cloud API utilties Node.JS SmartDC NOT installed"
     addwarn "Missing install of JPC Cloud API utilties Node.JS SmartDC in /opt/local/smartdc"
     addwarn "This is not fatal and your system will run ok"
     addwarn "Install info is at: http://wiki.joyent.com/wiki/display/jpc2/About+Using+the+Cloud+API#AboutUsingtheCloudAPI-InstallNode.js"
  else
    # make sure that /opt/local/smartdc is owned by root
    lib_smartdc_info "settng /opt/local/smartdc to be owned by root:wheel"
    chown -R root:wheel /opt/local
    chown -R root:wheel /opt/local/smartdc

    if [[ ! -f /opt/local/smartdc/bin/node ]]; then
       lib_smartdc_info "MISSING /opt/local/smartdc/bin/node - JPC Cloud API utilties Node.JS SmartDC NOT installed"
       addwarn "Missing node binary of JPC Cloud API utilties Node.JS SmartDC in /opt/local/smartdc/bin/node"
       addwarn "This is not fatal and your system will run ok"
       addwarn "Install info is at: http://wiki.joyent.com/wiki/display/jpc2/About+Using+the+Cloud+API#AboutUsingtheCloudAPI-InstallNode.js"
    else 
       NODE_VERSION=`/opt/local/smartdc/bin/node -v`; 
       lib_smartdc_info "JPC Cloud API utilties Node.JS ( ${NODE_VERSION} ) installed"
       if [[ ! -f /opt/local/smartdc/lib/node_modules/smartdc/package.json ]]; then
          lib_smartdc_info "MISSING SmartDC NPM install of JPC Cloud API utilties Node.JS - SmartDC NOT installed"
          addwarn "Missing SmartDC NPM install of JPC Cloud API utilties Node.JS SmartDC in /opt/local/smartdc/lib/node_modules/smartdc/"
          addwarn "This is not fatal and your system will run ok"
          addwarn "Install info is at: http://wiki.joyent.com/wiki/display/jpc2/About+Using+the+Cloud+API#AboutUsingtheCloudAPI-InstallNode.js"
       else
          SMARTDC_VERSION=`grep \"version\" /opt/local/smartdc/lib/node_modules/smartdc/package.json | cut -d: -f2 | tr -d \s | tr -d \" | tr -d \, 2> /dev/null`
          lib_smartdc_info "JPC Cloud API SmartDC utilties ( ${SMARTDC_VERSION} ) installed"

          # make sure that all scripts in /opt/local/smartdc use this version of node
          out=$( grep -r "^\#\!" /opt/local/smartdc/lib/node_modules/smartdc/bin | grep '/usr/bin/env node' | cut -d ':' -f1 | wc -l )
          if [ $out -ne 0 ]; then
             grep -r "^\#\!" /opt/local/smartdc/lib/node_modules/smartdc/bin | grep '/usr/bin/env node' | cut -d ':' -f1 | xargs sed -ri '' "/^\#\!.*/s//\#\!\/opt\/local\/smartdc\/bin\/node/"
          fi
       fi
    fi 
  fi
}

cleanup_logs() {
  # remove logs that are not needed on clean install
  lib_smartdc_info "cleaning up logs"
  find /var/log -type f | xargs rm -f

  # clear /var/tmp
  rm -rf /var/tmp/*
  rm -rf /tmp/*
}

prepare_image_disk() {
   # prepares $IMAGE_DISK by creating filesystems on the partitions 
   
   BOOT_DISK="${IMAGE_DISK}p1"
   ROOT_DISK="${IMAGE_DISK}p2"
   SWAP_DISK="${IMAGE_DISK}p3"

   # format image root partition
   lib_smartdc_info "Making filesystem on image root disk $ROOT_DISK"
   out=`newfs -J -L ROOT $ROOT_DISK` 
   if [[  $? -ne 0 ]]; then
      lib_smartdc_fatal "Failed to make filesystem on image root disk ( $ROOT_DISK ). Run newfs -L ROOT $ROOT_DISK for more info"
   fi

   # nothing needed for swap partition, but we will give some feedback anyway
   lib_smartdc_info "Making swap filesystem on swap disk $SWAP_DISK"
}

check_image_disk () {
   # checks to see if $IMAGE_DISK is available 
   # if it is available then partitions are created 

   echo " "
   echo " "
   read -p "WARNING!!! $IMAGE_DISK will be destroyed. Make super sure that $IMAGE_DISK is the proper one to destroy. [Y/N] " -n 1
   if [[ ! $REPLY =~ ^[Yy]$ ]];  then
      echo  " "
      echo  " "
      lib_smartdc_fatal "User selected not to run $0 by hitting key that was not a 'Y' or 'y'"
   else
      if [[ $IMAGE_DISK == "/dev/vtbd0" ]] ; then
         echo  " "
         echo  " "
         read -p "DANGER!!! $IMAGE_DISK is the main root disk for instances. This is your last chance to not desimate all data on $IMAGE_DISK. Most likely you do not want to do this. [Y/N] " -n 1
         echo  " "
         echo  " "
         if [[ ! $REPLY =~ ^[Yy]$ ]] ; then
            echo  " "
            echo  " "
            lib_smartdc_fatal "EXITING as $IMAGE_DISK is user backed out." 
         fi
      fi
   fi

   if [[ ! -e /dev/${IMAGE_DISK} ]]; then
     lib_smartdc_fatal "Image disk is not available to make image. Contact Joyent Support to make image disk ( /dev/${IMAGE_DISK} ) available." 
   fi 

   if [[ -z `which gpart` ]] ; then
     lib_smartdc_fatal "gpart not installed."
   fi

   # make sure device is not mounted
   echo " "
   echo " "
   lib_smartdc_info "Making sure that /dev/${IMAGE_DISK} is not mounted"
   umount -f /dev/${IMAGE_DISK} 2> /dev/null

   # print list of command to partition disk
   BOOT_DISK_PART_INFO=`gpart backup $SOURCE_DISK | grep "^1"`
   ROOT_DISK_PART_INFO=`gpart backup $SOURCE_DISK | grep "^2"`
   SWAP_DISK_PART_INFO=`gpart backup $SOURCE_DISK | grep "^3"`

   BOOT_DISK_PART_START=`echo $BOOT_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f3`
   ROOT_DISK_PART_START=`echo $ROOT_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f3`
   SWAP_DISK_PART_START=`echo $SWAP_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f3`

   BOOT_DISK_PART_END=`echo $BOOT_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f4`
   ROOT_DISK_PART_END=`echo $ROOT_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f4`
   SWAP_DISK_PART_END=`echo $SWAP_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f4`

   # gets size of partitions in bytes, note intiializing element 0 to nothing to make array elements align with partitons
   out=$(gpart list $SOURCE_DISK | grep Mediasize | cut -d: -f2 | cut -d '(' -f1 | tr -d ' ')
   SOURCE_DISK_PART_SIZE=("-1" $out)

   BOOT_DISK_PART_SIZE=${SOURCE_DISK_PART_SIZE[1]}
   ROOT_DISK_PART_SIZE=${SOURCE_DISK_PART_SIZE[2]}
   SWAP_DISK_PART_SIZE=${SOURCE_DISK_PART_SIZE[3]}

   BOOT_DISK_PART_TYPE=`echo $BOOT_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f2`
   ROOT_DISK_PART_TYPE=`echo $ROOT_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f2`
   SWAP_DISK_PART_TYPE=`echo $SWAP_DISK_PART_INFO | sed -r "s/\ +/:/g" | cut -d: -f2`

   BOOT_DISK_PART_SIZE_KB=$((${BOOT_DISK_PART_SIZE} / 1024))
   ROOT_DISK_PART_SIZE_KB=$((${ROOT_DISK_PART_SIZE} / 1024))
   SWAP_DISK_PART_SIZE_KB=$((${SWAP_DISK_PART_SIZE} / 1024))

   # check to see if a partiton exist on $IMAGE_DISK
   IMAGE_DISK_PART_INFO=$(gpart show $IMAGE_DISK)
   
   if [[ -z $IMAGE_DISK_PART_INFO ]] ; then
      lib_smartdc_info "No partition on $IMAGE_DISK"
   else
      lib_smartdc_info "Partition on $IMAGE_DISK:"
      lib_smartdc_info "$IMAGE_DISK_PART_INFO"
      lib_smartdc_info "Destroying partition on $IMAGE_DISK"
      gpart destroy -F $IMAGE_DISK
   fi
 
   lib_smartdc_info "Making GPT partition on $IMAGE_DISK"
   gpart create -s GPT $IMAGE_DISK
   
   lib_smartdc_info "Making boot partiton on $IMAGE_DISK of $BOOT_DISK_PART_SIZE"
   gpart add -t $BOOT_DISK_PART_TYPE -b $BOOT_DISK_PART_START -s ${BOOT_DISK_PART_SIZE}B -l BOOT $IMAGE_DISK

   lib_smartdc_info "Making root partiton on $IMAGE_DISK of $ROOT_DISK_PART_SIZE"
   gpart add -t $ROOT_DISK_PART_TYPE -b $ROOT_DISK_PART_START -s ${ROOT_DISK_PART_SIZE}B -l ROOT $IMAGE_DISK

   lib_smartdc_info "Making swap partiton on $IMAGE_DISK of $SWAP_DISK_PART_SIZE"
   gpart add -t $SWAP_DISK_PART_TYPE -b $SWAP_DISK_PART_START -s ${SWAP_DISK_PART_SIZE}B -l SWAP $IMAGE_DISK

   lib_smartdc_info "Installing bootloader on to boot partiton on ${IMAGE_DISK}p1"
   gpart bootcode -b /boot/pmbr -p /boot/gptboot -i 1 $IMAGE_DISK

   prepare_image_disk
}

copy_root_to_image_disk() {
  # copies data from root disk

  TARGET_ROOT_MNT_POINT='/mnt/image_root-target'

  # check for root target image root mount dir
  if [[ ! -d $TARGET_ROOT_MNT_POINT ]]; then
     lib_smartdc_info "creating $TARGET_ROOT_MNT_POINT"
     mkdir -p $TARGET_ROOT_MNT_POINT
  fi

  # mount ${IMAGE_DISK}2 aka. target root disk
  lib_smartdc_info "mounting root target image disk /dev/${IMAGE_DISK}p2"
  out=`mount /dev/${IMAGE_DISK}p2 $TARGET_ROOT_MNT_POINT` 
  if [[  $? -ne 0 ]]; then
     lib_smartdc_fatal "Failed to mount /dev/${IMAGE_DISK}p2 on $TARGET_ROOT_MNT_POINT"
  fi
 
  # make sure root mount is there
  MOUNT_CHECK=$(mount | grep ${IMAGE_DISK}p2 | grep $TARGET_ROOT_MNT_POINT | wc -l) 
  if [[ $MOUNT_CHECK -ne 1 ]]; then
     lib_smartdc_fatal "Failed to mount ${IMAGE_DISK}p2 on $TARGET_ROOT_MNT_POINT"
  fi

  # copy files from source root disk ( /dev/vtbd1 ) to target root disk ( /dev/vtbd2 )
  lib_smartdc_info "archive file copy from / to $TARGET_ROOT_MNT_POINT ( this can take up to 5 min )"
  cp -ax / $TARGET_ROOT_MNT_POINT

  # set permissions for copied tmp mount point /${TARGET_ROOT_MNT_POINT}/tmp
  chmod 1777 /${TARGET_ROOT_MNT_POINT}/tmp
  chmod 1777 /${TARGET_ROOT_MNT_POINT}/var/tmp

  # unmount $TARGET_ROOT_MNT_POINT
  umount $TARGET_ROOT_MNT_POINT

  # fsck the disks to make sure they are clean
  lib_smartdc_info "fscking ${IMAGE_DISK}p2"
  fsck -y -t ufs ${IMAGE_DISK}p2 

  # tunefs
  tunefs -j enable /dev/${IMAGE_DISK}p2

  # remove root target image root mount dir
  if [[ -d $TARGET_ROOT_MNT_POINT ]]; then
     lib_smartdc_info "removing $TARGET_ROOT_MNT_POINT"
     rm -rf $TARGET_ROOT_MNT_POINT 2> /dev/null
  fi
}

cleanup_lock_files() {
  # makes sure lock file is not in place on provisioning

  lib_smartdc_info "cleaning up lock files"
  rm -rf /var/spool/lock/*

  if [ -e $USER_SCRIPT_LOCKFILE ]; then
    rm -f $USER_SCRIPT_LOCKFILE
  fi
}

cleanup_root() {
  # creates clean root directory and check if root account has password set

  lib_smartdc_info "cleaning up root account"
  rm -f /root/.bash_history
  rm -f /root/.history
  history -c
  rm -f /root/.bash_history
  rm -f /root/.history
  history -c
  rm -f /root/.bash_history
  rm -f /root/.history
  rm -f /root/.lesshst
  rm -f /root/.viminfo

  echo " "
  echo " "
  read -p "Do you want the root account on this image to have no default password and only SSH public key authentication enabled ( RECOMMENDED ). [Y/N] " -n 1
  if [[ ! $REPLY =~ ^[Yy]$ ]];  then
     echo  " "
     echo  " "
     lib_smartdc_info "User selected to keep root password to whatever it is set to the same for all images."
  else
     echo  " "
     echo  " "
     chpass -p '' root
     chpass -p '' toor
     lib_smartdc_info "Root password is disabled and only root can log in via SSH public keys."
  fi

  if [[ -e /var/mail/root ]] ; then
     rm -rf /var/mail/root
  fi
}

cleanup_other_users() {
  # checks to ensure that other user accounts that should not be on an clean instance are not there
  # Mainly this is a Joyent check for when systems are created from an ISO image that require a user
  # account added on initial install

  lib_smartdc_info "cleaning up other user account"

  # looks for list of users that should not be on system
  USERLIST='joyent'
  FILELIST='passwd'
  for user in $USERLIST; do
     for file in $FILELIST; do
        local passwd=$(grep "^${user}:" /etc/${file} | awk -F ':' '{print $2}')
        if [[ -n $passwd ]] ; then
          lib_smartdc_info "$user user exist in /etc/${file}. This is a potential vulnerability"
          lib_smartdc_fatal "Need to remove $user user."
        fi
   done

     if [[ -d "/usr/home/$user" ]] ; then
       lib_smartdc_info "/usr/home/$user exist. This is a potential vulnerability"
       lib_smartdc_fatal "Need to remove /usr/home/$user."
     fi
   
     GROUPFILELIST='group' 
     for groupfile in $GROUPFILELIST; do
        out=$(grep $user /etc/${groupfile} | wc -l)
        if [ $out -ne 0 ]; then
           addwarn "$user user exist /etc/${groupfile}. This is a potential vulnerability and user should be removed."
        fi 
     done
  done

  # check for passwors set for any other user
  local USERLIST=$(grep -E "^[[:alpha:]]+:[^\*\!\:]" /etc/passwd | awk -F ':' '{print $1}')
  for user in $USERLIST; do
    addwarn "$user user exist with password set in /etc/passwdshadow. This is a potential vulnerability"
  done
}

cleanup_ssh() {
  # prepare ssh for new image creation and new keys
  # you really wnat systems to create their own unique keys on provisioning
  # and make sure that there are no default keys for the SSHD server
  # It is best to update root authorized_keys using config management ( i.e. Chef or Puppet )
  # You can use the mdata to update keys after the initial provisioning, however you will have to use
  # mdata and run set-root-authorized-keys - more info is here:
  # https://help.joyent.com/entries/23022808-updating-SSH-keys-on-Linux-systems-via-Mdata

  lib_smartdc_info "cleaning up ssh"
  find /etc/ssh -type f -name "ssh_host_*" | xargs rm -f    

  # remove /root/.ssh files
  # if you need these files on provisioning please use config management 
  FILELIST='authorized_keys known_hosts id_dsa id_dsa.pub id_rsa id_rsa.pub ssh_config'
  for FILE in $FILELIST; do
     if [ -f "/root/.ssh/$FILE" ]; then
        rm -r /root/.ssh/$FILE
     fi
  done 
}

cleanup_disks() {
  # remove datadisk from /etc/fstab

  out=$(grep "/dev/vtbd1p1" /etc/fstab | wc -l | tr -d ' ')
  if [[ $out -ne 0 ]] ; then
     lib_smartdc_info "removing /dev/vtbd1p1 entries from fstab"
     sed -iE '/^\/dev\/vtbd1p1/d' /etc/fstab
  fi
}

cleanup_metadata() {
  # remove any existing metadata 

  lib_smartdc_info "cleaning up meta data"
  rm -f /root/user-script
  rm -f /root/user-data

  if [ -e $USER_SCRIPT_FILE ]; then
     rm -f $USER_SCRIPT_FILE
  fi
}

cleanup_hostname() {
  # remove any existing hostnames

  lib_smartdc_info "removing hostname"
  sed -iE '/^hostname=.*/s//hostname=\"\"/' /etc/rc.conf
  if [ -e /etc/hostname ] ; then
     rm -f /etc/hostname
  fi
}

prepare_freebsd() {
  # FreeBSD specific commands go here
  
  lib_smartdc_info "Removing common files for all FreeBSD systems"
  
  # Remove any DHCP leases
  find /var/db/ -type f -name "dhclient.leases.*" | xargs rm -f

  # Remove NTP drift file
  rm -f /var/db/ntpd.drift

  # Remove locate database
  rm -f /var/db/locate.database

  # Remove entropy
  find /var/db/entropy/ -type f -name "saved-entropy.*" | xargs rm -f
  
  if [[ ! -f $DUO_LOGIN_CONFIG ]]; then
    addwarn "DUO login config file not found. $DUO_LOGIN_CONFIG is required for DUO two factor SSH support"
  else
    out=$(stat -f %p $DUO_LOGIN_CONFIG)
    if [[ ${out} -ne 100600 ]]; then
      addwarn "$DUO_LOGIN_CONFIG must be read only by root. Permissions are currently set to $out"
    fi

    out=$(stat -f %u $DUO_LOGIN_CONFIG)
    if [[ ${out} -ne 0 ]]; then
      addwarn "$DUO_LOGIN_CONFIG must be owned by root. Permissions are currently set to owner $out"
    fi

    # Check to see that no DUO info is set in config file
    duo_config_ikey=$( grep "^ikey" $DUO_LOGIN_CONFIG | cut -d "=" -f2 | tr -d ' ' )
    duo_config_skey=$( grep "^skey" $DUO_LOGIN_CONFIG | cut -d "=" -f2 | tr -d ' ' )
    duo_config_host=$( grep "^host" $DUO_LOGIN_CONFIG | cut -d "=" -f2 | tr -d ' ' )

    if [ ! -z $duo_config_ikey ]; then
      addwarn "ikey set in $DUO_LOGIN_CONFIG. This should not be set on default images... unless you really want it set."
    fi

    if [ ! -z $duo_config_skey ]; then
      addwarn "skey set in $DUO_LOGIN_CONFIG. This should not be set on default images... unless you really want it set."
    fi

    if [ ! -z $duo_config_host ]; then
      addwarn "host set in $DUO_LOGIN_CONFIG. This should not be set on default images... unless you really want it set."
    fi

    out=$(stat -f %g $DUO_LOGIN_CONFIG)
    if [[ ${out} -ne 0 ]]; then
      addwarn "$DUO_LOGIN_CONFIG must be in the group root. Permissions are currently set to group $out"
    fi
  fi

  if [[ ! -f $DUO_LOGIN_BIN ]]; then
    addwarn "DUO longin binary is not in $DUO_LOGIN_BIN. This is needed for DUO two factor authentication"
  fi

  # Check to see if DUO is configured in SSHD config file
  out=$( grep "^ForceCommand" /etc/ssh/sshd_config | grep $DUO_LOGIN_BIN | wc -l )
  if [ $out -ne 0 ]; then
    addwarn "DUO is active in SSHD config file. This should not be set on default images... unless you really want it set."
  fi

  # check that serial port used for Meta data is readable by root and group
  if [ ! -e "$MDATA_SERIAL_PORT" ]; then
     lib_smartdc_fatal "Mdata serial port does not exist. Make sure that $MDATA_SERIAL_PORT is on your system or this the proper port"
  fi

  # check owner and group are set to uucp and dialer
  serial_user=$( /usr/bin/stat -f %u $MDATA_SERIAL_PORT )
  if [ $serial_user -ne 66 ]; then
     addwarn "owner of $MDATA_SERIAL_PORT is $serial_user - recommended that you set owner to be uucp"
  fi

  serial_group=$( /usr/bin/stat -f %g $MDATA_SERIAL_PORT )
  if [ $serial_group -eq 0  ]; then
     addwarn "group of $MDATA_SERIAL_PORT is $serial_group - recommended that you set group not to be root ( i.e. dialer )"
  fi

  # check to see that owner and group permissions are only rw
  owner_read_and_write_rights=$( /usr/bin/stat -f %p $MDATA_SERIAL_PORT | cut -c 3 )
  if [ $owner_read_and_write_rights -ne 6 ]; then
     addwarn "owner read\write rights not set for $MDATA_SERIAL_PORT - it is recommended that you set owner to rw"
  fi

  group_read_and_write_rights=$( /usr/bin/stat -f %p $MDATA_SERIAL_PORT | cut -c 4 )
  if [ $group_read_and_write_rights -ne 6 ]; then
     addwarn "group read\write rights not set for $MDATA_SERIAL_PORT - it is recommended that you set group to rw"
  fi

  world_read_and_write_rights=$( /usr/bin/stat -f %p $MDATA_SERIAL_PORT | cut -c 5 )
  if [ $world_read_and_write_rights -ne 0 ]; then
     addwarn "world read\write rights set for $MDATA_SERIAL_PORT - it is recommended that you limit access to only owner and group"
  fi

  # make sure sshd is running at boot
  out=$(grep -iE 'sshd_enable=\"yes\"' /etc/rc.conf | wc -l | tr -d ' ')
  if [[ $out -eq 0 ]] ; then
    lib_smartdc_fatal "SSHD is not enabled to start in /etc/rc.conf - this needs to be enabled." 
  fi  

  # make sure ntpd is running at boot
  out=$(grep -iE 'ntpd_enable=\"yes\"' /etc/rc.conf | wc -l | tr -d ' ')
  if [[ $out -eq 0 ]] ; then
    addwarn "NTPD is not enabled to start in /etc/rc.conf"
    addwarn "It is highly recommended that you run NTPD"
  fi  

  # make sure that ntpd is configured to listen
  out=$(ntpq -pn | grep -E "\.INIT\.(.*)(0.000)(.*)(0.000)(.*)(0.000)" | wc -l)
  if [[ ${out} -gt 3 ]]; then
    addwarn "NTPD seems has more than 3 time server failures"
    addwarn "run 'ntpq -pn' to verify that time servers are updating NTPD"
  fi

  # if a /etc/localtime file is missing set it to UTC
  if [ ! -e /etc/localtime ]; then
    lib_smartdc_info "/etc/localtime not set. Setting it to UTC"
    cp /usr/share/zoneinfo/UTC /etc/localtime
  fi

  # make sure audoboot time is set and at a low at boot
  out=$(grep -iE 'autoboot_delay=' /boot/loader.conf | cut -d '=' -f2 | tr -d \")
  if [[ -z $out ]] ; then
    addwarn "autoboot_delay is not set in /boot/loader.conf"
    addwarn "It is highly recommended that you set this to 5 seconds or less to limit delay on boot - autoboot_delay=\"5\""
  fi

  if [[ $out -gt 5 ]] ; then
    addwarn "autoboot_delay is greater than 5 seconds in /boot/loader.conf"
    addwarn "It is highly recommended that you set this to 5 seconds or less to limit delay on boot"
  fi
}

freebsd_fixes() {
  # specific fixes for freebsd

  FREEBSD_VERSION=$(grep "bsd_distro_version:" $JOYENT_VERSION_FILE | cut -d':' -f 2 | tr -d ' ')

  # Specific fixes for freebsd version 9.1 
  if [[ $FREEBSD_VERSION == "9.1" ]] ; then
     lib_smartdc_info "Applying specific fixes for freebsd $FREEBSD_VERSION"

     # Check for VirtIO kernel modules
     lib_smartdc_info "Checking for VirtIO kernel modules located in /boot/modules for freebsd $FREEBSD_VERSION"
     
     MODULEFILELIST='if_vtnet.ko virtio.ko virtio_blk.ko virtio_pci.ko'
     for modulefile in $MODULEFILELIST; do
        if [ ! -e "/boot/modules/$modulefile" ] ; then
          lib_smartdc_fatal "VirtIO kernel module file /boot/modules/$modulefile needs to be located in /boot/modules"
        fi
     done

     # Check that VirtIO kernel modules are loaded on boot
     lib_smartdc_info "Checking for VirtIO kernel modules installed on boot for freebsd $FREEBSD_VERSION"

     MODULELIST='virtio_load virtio_pci_load virtio_blk_load if_vtnet_load'
     for module in $MODULELIST; do
        local module_check=$(grep "$module" /boot/loader.conf | grep -I "yes")
        if [[ -n $module_check ]] ; then
          lib_smartdc_fatal "VirtIO kernel module ( $module ) needs to be loaded in /boot/loader.conf: ${module}=\"YES\""
        fi
     done

     # Check that VirtIO kernel modules are loaded now
     lib_smartdc_info "Checking for VirtIO kernel modules loaded now"

     MODULELIST='virtio.ko virtio_pci.ko virtio_blk.ko if_vtnet.ko'
     for module in $MODULELIST; do
        local module_check=$(kldstat | grep $module | wc -l)
        if [[ $module_check -eq 0 ]] ; then
          lib_smartdc_fatal "VirtIO kernel module ( $module ) is not loaded according to kldstat"
        fi
        local module_debug_check=$(kldstat | grep $module | grep -I "debug" | wc -l)
        if [[ $module_debug_check -ne 0 ]] ; then
          addwarn "VirtIO kernel debug module ( $module ) is loaded according to kldstat"
        fi
     done
     
     # Check that vtnet0 and vtnet1 are in /etc/rc.conf and configured for DHCP
     lib_smartdc_info "Checking for VirtIO nic are configured for dhcp on boot"
     vtnet0_etc_check=$(grep "ifconfig_vtnet0=" /etc/rc.conf | grep -v "#" )
     if [[ ! -z $vtnet0_etc_check ]] ; then
        vtnet0_dhcp_check=$( echo $vtnet0_etc_check | grep "\"DHCP\"" | wc -l | tr -d ' ' )
        if [[ $vtnet0_dhcp_check -eq 0 ]] ; then
           addwarn "Missing ifconfig_vtnet0=\"DHCP\" in /etc/rc.conf. Normally, this is needed to have Public Internet VirtIO NIC available on boot"   
        fi
     else
        addwarn "Missing ifconfig_vtnet0=\"DHCP\" in /etc/rc.conf. Normally, this is needed to have Public Internet VirtIO NIC available on boot"   
     fi     

     vtnet1_etc_check=$(grep "ifconfig_vtnet1=" /etc/rc.conf | grep -v "#" )
     if [[ ! -z $vtnet1_etc_check ]] ; then
        vtnet1_dhcp_check=$( echo $vtnet1_etc_check | grep "\"DHCP\"" | wc -l | tr -d ' ' )
        if [[ $vtnet1_dhcp_check -eq 0 ]] ; then
           addwarn "Missing ifconfig_vtnet1=\"DHCP\" in /etc/rc.conf. Normally, this is needed to have Private Internet VirtIO NIC available on boot"   
        fi
     else
        addwarn "Missing ifconfig_vtnet1=\"DHCP\" in /etc/rc.conf. Normally, this is needed to have Private Internet VirtIO NIC available on boot"   
     fi     
  fi 

}

check_lib_smartdc() {
  # makes sure that all is in /lib/smartdc and configured for production

  # Make sure debugging is off on all scripts
  for OUT in `grep -e "^DEBUG=" /lib/smartdc/*`; do
    FILENAME=`echo $OUT | cut -d ':' -f 1`
    DEBUG_LEVEL=`echo $OUT | cut -d '=' -f 2`
    if [ $DEBUG_LEVEL -gt 0 ]; then
       addwarn "Debug level is set to $DEBUG_LEVEL in $FILENAME"
    fi
  done

  # Check that all files are in /lib/smartdc
  # this is updaed as files change locations
  FILELIST='duo-two-factor-configurator disable-firewall format-secondary-disk joyent_dataset_changelog joyent_motd_footer joyent_product_info joyent_rc.local joyent_version lib_smartdc_scripts.cfg mdata-get prepare-image README run-user-script set-hostname set-root-authorized-keys'
  for FILE in $FILELIST; do
     if [ ! -f "/lib/smartdc/$FILE" ]; then
        lib_smartdc_fatal "Missing needed file - /lib/smartdc/$FILE"   
     fi
  done

  # Check for symlinks in /etc
  LINKLIST='joyent_dataset_changelog joyent_version product'
    for LINK in $LINKLIST; do
     if [ ! -L "/etc/$LINK" ]; then
        lib_smartdc_fatal "Missing sym link - /etc/$LINK"   
     fi
  done

  # Make sure that call in /etc/rc.local to /lib/smartdc/joyent_rc.local
  OUT=`grep -e "^(/lib/smartdc/joyent_rc.local)" /etc/rc.local`
  if [ -z $OUT ]; then
     lib_smartdc_fatal "Missing call in /etc/rc.local to /lib/smartdc/joyent_rc.local"
  fi

  # make sure that /lib/smartdc is owned by root
  lib_smartdc_info "settng /lib/smartdc to be owned by root:wheel"
  chown -R root:wheel /lib/smartdc
}

## MAIN ##

# Make sure user is root
lib_smartdc_check_root

# check for image disk and prepare it if it is present
check_image_disk

# ask if they really want to do this
separator
read -p "This script is specific for $TARGET_DISTRO and will delete and change lots of stuff. This is not meant to be ran on a production system. Are you sure you want to do this? " -n 1
if [[ ! $REPLY =~ ^[Yy]$ ]]
then
    echo  " "
    echo  " "
    lib_smartdc_fatal "User selected not to run $0 by hitting key that was not a 'Y' or 'y'"
fi
echo  " "
echo  " "

# check to make sure it is proper system for this version of prepare-image
vendor=$(grep 'bsd_distro:' $JOYENT_VERSION_FILE | cut -d':' -f 2 | tr -d ' ')
TARGET_DISTRO=$( echo $TARGET_DISTRO | tr '[:upper:]' '[:lower:]')
if [ ${vendor} != $TARGET_DISTRO ]; then
   lib_smartdc_fatal "OS ( $vendor ) not handled by this script ( $0 )"
fi

# specific things to do per diff version of freebsd
freebsd_fixes

prepare_freebsd
check_lib_smartdc
check_for_smartdc
cleanup_logs
cleanup_lock_files
cleanup_disks
cleanup_ssh
cleanup_root
cleanup_other_users
cleanup_metadata
cleanup_hostname
copy_root_to_image_disk

if [[ ${WARNING} != "" ]] ; then
  printf "\n"
  separator
  printf "${WARNING}"
  separator
  printf "\n\n"
  exit 1
else
  printf "\n"
  separator
  printf "(info) You may now create an image of this system using disk2 ( $IMAGE_DISK )\n"
  printf "(info) Make sure you take a snapshot of the zfs vol that holds ${IMAGE_DISK}1\n"
  separator
  printf "\n\n"
  exit 0
fi
